# Shape Packing Solver

一个基于 Python 的应用程序，用于解决二维不规则形状的打包问题。它提供了命令行界面（CLI）和图形用户界面（GUI）两种方式，旨在将一组给定的形状打包到一个容器中，并最大化空间利用率。

打包好的`.exe`文件下载地址：[https://github.com/entishl/nkrbehgamehelper/releases]
在这里是用于nikke 生化危机联动小游戏的武器装箱求解。
也可用于其它类似游戏。
需要自定义形状修改`sharps.json` 文件即可。

该求解器的核心是基于谷歌的 **OR-Tools (CP-SAT)**，一个强大的约束规划求解器。

## 功能特性

- **双重接口**: 既可用作脚本化的命令行工具，也可用作交互式的用户友好图形界面。
- **可定制的容器**: GUI 允许用户在 9x9 的网格上自定义容器的形状。
- **基于约束的求解**: 利用 CP-SAT 求解器处理复杂的打包约束，包括非重叠规则。
- **形状分解**: 自动将不规则形状分解为一组矩形，以便于求解器处理。
- **交互式可视化**: GUI 提供了最终打包布局的实时可视化。
- **灵活的控制**: 用户可以指定形状数量，为求解器设置时间限制，并“锁定”某些形状以确保它们被包含在解决方案中。

## 系统要求

- Python 3.x
- Tkinter (通常随 Python 一起安装)
- Google OR-Tools

您可以使用 pip 安装所需的库：

```bash
pip install ortools
```

## 自编译

```bash
pip install ortools
pyinstaller gui.spec
```

如需以后可以自行修改shapes.json，以实现自定义形状。
可自行取消`gui.spec`最后一段的注释，以文件夹方式打包。

## 如何使用

### 1. GUI 模式

要运行图形界面，请执行 `gui.py` 脚本：

```bash
python gui.py
```

**界面指南:**

1. **容器形状**: 在左侧的 9x9 网格中单击单元格，以定义可用于打包的区域。白色单元格可用，黑色单元格被阻挡。
2. **形状数量**: 使用输入字段和箭头按钮指定要打包的每种形状的数量。
3. **锁定形状**: 单击形状旁边的锁形图标 (🔒) 以强制求解器将该形状包含在解决方案中。
4. **时间限制**: 为计算设置一个时间限制（以秒为单位）。
5. **计算**: 按下“Calculate”按钮开始打包过程。结果将显示在右侧的输出面板中。

### 2. 命令行模式

要使用命令行界面，请使用所需参数运行 `main.py` 脚本。

```bash
python main.py --shape_counts "shape1=2,shape2=1" --board_size "10,10"
```

**参数:**

- `--shape_counts` (必需): 一个逗号分隔的字符串，指定要打包的每种形状的名称和数量。例如: `'shape_L=2,shape_T=1'`
- `--board_size` (可选): 矩形板的尺寸。默认: `'10,10'`。
- `--shapes_file` (可选): 包含形状定义的 JSON 文件的路径。默认: `shapes.json`。

## 项目结构

```
.
├── gui.py              # GUI 应用程序的主脚本
├── main.py             # 命令行界面的主脚本
├── shapes.json         # 包含形状定义的默认 JSON 文件
├── src/
│   ├── solver.py       # 使用 OR-Tools 的核心打包逻辑
│   ├── data_models.py  # 定义数据结构 (Shape, PackingResult 等)
│   ├── decomposition.py# 用于分解不规则形状的逻辑
│   ├── visualizer.py   # 在 GUI 画布上渲染结果
│   └── utils.py        # 实用功能函数
└── ...
```

## 技术实现

该问题被建模为一个**约束规划**问题。

1. **形状分解**: 每个不规则形状（由一组点定义）首先被分解为一系列更小的、不重叠的矩形。这是一个关键的预处理步骤，因为 CP-SAT 求解器的 `AddNoOverlap2D` 约束是针对矩形工作的。
2. **CP-SAT 模型**:
    - 为每个形状创建布尔变量 (`is_used`)，以决定是否放置该形状。
    - 整数变量 (`x`, `y`) 表示每个形状左上角的位置。
    - 主要约束是 `AddNoOverlap2D`，它应用于所有形状的所有分解矩形，以确保它们不会重叠。
    - 附加约束确保形状被放置在容器的允许单元格内。
3. **目标**: 模型的目标是**最大化**已放置形状的**总面积** (`sum(shape.area * is_used)`)。
4. **求解器**: CP-SAT 求解器探索解空间，以找到一个满足所有约束同时最大化目标函数的可行或最优的形状排列。使用时间限制来确保求解器在合理的时间内返回一个好的解决方案。
